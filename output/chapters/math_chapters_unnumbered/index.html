<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="pandoc" name="generator"/>
<title></title>
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<link href="../../style/style.css" rel="stylesheet" type="text/css"/>
<link href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic|Merriweather:400,300,300italic,400italic,700,900,700italic,900italic" rel="stylesheet" type="text/css">
</link></head>
<body>
<div id="chapter">
<div id="TOC">
<ul>
<li><a href="#that-math-chapter-from-1d-to-4d">That Math Chapter: From 1D to 4D</a><ul>
<li><a href="#how-artists-approach-math">How Artists Approach Math</a></li>
<li><a href="#about-this-chapter">About this Chapter</a></li>
<li><a href="#one-dimension-using-change">One Dimension: Using Change</a><ul>
<li><a href="#interpolation">Interpolation</a><ul>
<li><a href="#linear-interpolation-the-oflerp">Linear Interpolation: The <code>ofLerp</code></a></li>
<li><a href="#affine-mapping-the-ofmap">Affine Mapping: The <code>ofMap</code></a></li>
<li><a href="#range-utilities">Range Utilities</a></li>
</ul></li>
<li><a href="#beyond-linear-changing-change">Beyond Linear: Changing Change</a><ul>
<li><a href="#quadratic-and-cubic-change-rates">Quadratic and Cubic Change Rates</a></li>
</ul></li>
<li><a href="#splines">Splines</a></li>
<li><a href="#tweening">Tweening</a></li>
</ul></li>
<li><a href="#more-dimensions-some-linear-algebra">More Dimensions: Some Linear Algebra</a><ul>
<li><a href="#the-vector">The Vector</a><ul>
<li><a href="#vector-algebra">Vector Algebra</a></li>
</ul></li>
<li><a href="#the-matrix">The Matrix™</a><ul>
<li><a href="#matrix-multiplication-as-a-dot-product">Matrix Multiplication as a dot product</a></li>
<li><a href="#matrix-algebra">Matrix Algebra</a></li>
</ul></li>
<li><a href="#the-full-stack">"The Full Stack"</a><ul>
<li><a href="#translation-matrices">Translation matrices</a></li>
<li><a href="#srt-scale-rotate-translate-operations">SRT (Scale-Rotate-Translate) operations</a></li>
<li><a href="#using-matrices-and-quaternions-in-openframeworks">Using Matrices and Quaternions in openFrameworks</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="that-math-chapter-from-1d-to-4d">That Math Chapter: From 1D to 4D</h1>
<p><em>by <a href="http://omershapira.com">Omer Shapira</a></em></p>
<p><strong>NOTE: This chapter is formatted with MD and LaTeX. Github won't render it properly. Try <a href="http://stackedit.io">stackedit.io</a> instead</strong></p>
<h2 id="how-artists-approach-math">How Artists Approach Math</h2>
<p>Math is a curious thing in arts. Many artists reference it directly as inspiration for their work, from Leonardo Da Vinci's <em>Vitruvian Man</em>, through Escher's different views of fields of numbers, to the tedious namedrop of "The Golden Ratio" for every concept product made in a design school since the iPhone (if you think that's a neat idea, please read this chapter more than twice). <strong>[mh: while this is humorous, it's also unfriendly]</strong></p>
<p>Computers allowed simulation to happen, which means people could draw more than (and faster than) they could think. When Benoît Mandelbrot worked for IBM, his attempt at printing the density map of a self-repeating sequence of complex numbers – something that would have taken forever for a human hand and head – resulted in a scientific measurement being reappropriated for its aesthetic value, in what we now call <a href="https://en.wikipedia.org/wiki/Fractal_art">Fractal Art</a>, a family that also grew to include tree-like structures generated from <a href="http://en.wikipedia.org/wiki/L-system">L-System</a> grammars and three-dimensional extensions with lovely names such as "Mandelbulb". It's acceptable to call these things <em>Art</em>, because the thought that mathematicians had done this deliberately in their work would simply confuse the audience.</p>
<p>Thing is, we know better than all of that. Math is everywhere in Art, just like Art is everywhere in Math. When using a brush or pen or chisel, we're taking advantage of the hard work that nature is doing, calculating physics, rendering things perfectly for us, all in real time. <del>Our brains apply direct aesthetic knowledge to a work, and we're done. WYSIWYG.</del> <strong>[mh: these two sentences could be omitted - first one is a bit indirect for saying "we manipulate visuals by hand," and the second, not everyone will know wysiwyg]</strong> In the computer world, none of that is true. Things like L-Systems had to be created for us to use, because our hands can't reach into the computer. If you're doing any bit of digital art, the math is happening somewhere, whether you control it or not. This chapter will try to explain some of the basics of the black arts of graphics programming. I wish I could make this chapter 5 times as long and include the really neat stuff, but that would make this book too heavy to put in a rucksack.</p>
<h2 id="about-this-chapter">About this Chapter</h2>
<p>A Math chapter for a book about graphics will always miss out on many ideas. In fact, there are entire books covering "math for graphics", mostly consisting of references to other books, focusing on a specific topic (like Linear Algebra, Multivariable Calculus, Differential Geometry, and many other words mysteriously connected to other words). This chapter must therefore be very concise about ideas. All topics here are explained in a friendly way, but please - never fear googling a thing for which you need better examples.</p>
<p>This chapter will be divided into <em>'numbers of D's'</em> : we'll start from one dimension, and slowly explore the possibilities of using scale and change in different dimensions. <strong>[mh: this sentence might be a little unclear for newbies, as in why do I care about scale and change.]</strong> Depending on how you choose to read it, this section contains hundreds of Mathematicians' lifetime research, or in other words, several classes of college math, so it's worth bookmarking.</p>
<p>When bringing math to innocent readers, most programming books will try to explain the idea, not necessarily the exact implementation. This book is no different. This chapter contains detailed breakdowns of concepts, but if you want to find out what's going on under the hood, there's no alternative to reading the source code - in fact, since all the math here is only a few lines long - it's actually <em>encouraged</em> to have a look at the source.</p>
<h2 id="one-dimension-using-change">One Dimension: Using Change</h2>
<p>Let's start our journey by looking at the number line. It's a stretch of numbers going to infinity in both the positive and negative direction. Suppose we were ants or microbes, so that we could stand on exactly one value here, and travel to any other value by walking in that direction. That's pretty much the definition of a <em>dimension</em>. It's an infinite collection of values that are all accessible, and any value of it can be described with one number. As you're about to see, these properties are going to enable quite a lot of options.</p>
<p><strong>[GRAPHICS: The Number Line. Reference added]</strong></p>
<h3 id="interpolation">Interpolation</h3>
<h4 id="linear-interpolation-the-oflerp">Linear Interpolation: The <code>ofLerp</code></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofLerp(<span class="dt">float</span> start, <span class="dt">float</span> stop, <span class="dt">float</span> amt)</code></pre>
<p>As Randall Munroe (the author of xkcd) once put it, if you see a number larger than 7 in your page, you're not doing real math. To prove ourselves worthy, this part will only involve numbers between 0 and 1.</p>
<p>Those of you that have already done a little time-based or space-based work have probably noticed that you can often describe elements of your work as sitting on a line between two known points. A frame on a timeline is at a known location between 00:00:00 and the runtime of the film, a scrollbar is pointing to a known location between the beginning and the end of a page. That's exactly what <code>lerp</code> does.</p>
<p>With the <code>lerp</code> function, you can take any two quantities, in our case <code>start</code> and <code>stop</code>, and find any point between them, using amounts (<code>amt</code>) between 0 and 1. To be verbose: <span class="math">\[\text{lerp}\left(a,b,t\right) = t\cdot b+\left(1-t\right)\cdot a\]</span></p>
<h5 id="note-what-does-linear-really-mean">Note: What does <em>linear</em> really mean?</h5>
<p>Engineers, Programmers and English Speakers like to think of <em>linear</em> as <em>anything you can put on a line</em>. Mathematicians, having to deal with all the conceptual mess the former group of people creates, define it <em>anything you can put on a line <strong>that begins at (0,0)</strong></em>. There's good reasoning behind that, which we will see in the discussion about Linear Algebra. In the meantime, think of it this way:</p>
<blockquote>
<p>A <em>Linear Transform</em> takes any line that has a value 0 at the point 0 and returns a line with the same property, <span class="math">\(f\left(x\right)=ax\)</span>. If it returns a line value different from 0 at <span class="math">\(x=0\)</span>, <span class="math">\(f\left(x\right)=ax + b\)</span>, it's an <em>Affine Transform</em> instead.</p>
</blockquote>
<p>At this point you probably know, but it's worth repeating: Those two transformations may either change lines into lines, or in some degenerate cases, lines to points. For example, <span class="math">\(f\left(x\right) = x^{2}\)</span> is totally not linear.</p>
<h5 id="exercise-save-nasas-mars-lander">Exercise: Save NASA's Mars Lander</h5>
<p>In 1999, an masterpiece of engineering was making its final approach to Mars. All instruments were showing that the approach distance matched the speed, and that it's just about to get there and do some science. But instead, it did something rather rude: it crashed into the red planet. An investigation made later by NASA revealed that while designing the lander, one team worked with their test equipment set to <em>centimetres</em>, while the other had theirs set to <em>inches</em>. <strong>By the way, this is all true.</strong></p>
<p>Help the NASA teams work together: write a function that converts centimetres to inches. For reference, <span class="math">\(1_{\text{in}} = 2.54_{\text{cm}}\)</span>. Test your result against three different real-world values. Tip: Its much easier to start solving with pen and paper than it is with a keyboard.</p>
<p><strong>Think:</strong></p>
<ol style="list-style-type: decimal">
<li>Why can we use <code>lerp</code> outside the range of 0 and 1?</li>
<li>What would it take to write a function that converts inches into centimetres?</li>
</ol>
<h4 id="affine-mapping-the-ofmap">Affine Mapping: The <code>ofMap</code></h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofMap(<span class="dt">float</span> value, <span class="dt">float</span> inputMin, <span class="dt">float</span> inputMax, <span class="dt">float</span> outputMin, <span class="dt">float</span> outputMax, <span class="dt">bool</span> clamp = <span class="kw">false</span>)</code></pre>
<p>In the last discussion, we saw how by using <code>lerp</code>, any value between two points can be <em>linearly</em> addressed as a value between 0 and 1. That's very convenient, and therefore the reason we build most of our arbitrary numerical ranges (<code>ofFloatColor</code>, for example) in the domain of 0 and 1.</p>
<p>However, when dealing with real world problems, programmers run into domains of values that they wish to map to other ranges of values, neither of which are confined to 0 and 1. For example, someone trying to convert the temperature in Celsius to Fahrenheit won't be able to use a <code>lerp</code> by itself - the domain we care about isn't between 0 and 1. Surely, the way of doing that must involve a <code>lerp</code>, but it needs a little help.</p>
<p>If we want to use the <code>lerp</code> function, we're aiming to get it to the range between 0 and 1. We can do that by knocking <code>inputMin</code> off the input <code>value</code> so that it starts at 0, then dividing by the size of the domain: <span class="math">\[x=\frac{\text{value}-\text{inputMin}}{\text{inputMax}-\text{inputMin}}\]</span> Now that we've tamed the input domain to be between 0 and 1, we do the exact opposite to the output: <code>ofMap(value, inputMin, inputMax, outputMin, outputMax)</code> <span class="math">\(=\frac{\text{value}-\text{inputMin}}{\text{inputMax}-\text{inputMin}}\cdot\left(\text{outputMax}-\text{outputMin}\right)+\text{outputMin}\)</span></p>
<p>Here's an example. Let's say we're given a dataset in Farenheit. Farenheit sets 0 to be the freezing point of brine and 100 to be the body temperature of a slightly ill British human (duh?). In order to do <em>anything</em> with that, we first need to convert that to Celsius, which at least uses <em>The Same Damn Substance™</em> for 0 and 100: Water. Now, we happen to know that water freezes at <span class="math">\(32_{\text{f}}\)</span> and boils at <span class="math">\(212_{\text{f}}\)</span>, so we have the same exact objective range, now it's time to map. We'll use an array for this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">float</span>&gt; farenheitValues;
<span class="co">// we'll skip over the code that fills them up, as somebody else has done it</span>
vector&lt;<span class="dt">float</span>&gt; celsiusValues; <span class="co">//Sets up an empty C++ vector, which is a dynamic array</span>
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; farenheitValues.size() ; ++i){
	celsiusValues.pushBack(ofMap(<span class="dv">32</span>, <span class="dv">212</span>, <span class="dv">0</span>, <span class="dv">100</span>, farenheitValues[i]));
}</code></pre>
<p>Watch what we did here. We took the <em>domain</em> of 32 to 212 and converted it to a <em>range</em> of 0 to 100. There are two things to note about that:</p>
<ul>
<li>In Mathematics, we often use the words <em>domain</em> and <em>range</em> as origin and target. Using those terms allows us to introduce another concept we care about: <em>Separation of Concern</em>. If we know that every input a function takes is guaranteed to be in a certain <em>domain</em>, we can engineer it so it guarantees an output in a certain <em>range</em>, and make sure it doesn't fail. In fact, this is the mathematical definition of a function:</li>
</ul>
<blockquote>
<p>A Function is a Mathematical object that maps <em>every</em> value of a certain domain to a <em>single</em> value of a certain range.</p>
</blockquote>
<ul>
<li>We defined the range of 32 to 212 as two points we know on a line. The actual range of temperatures is -459.67 (the absolute zero, in Farenheits) to somewhere very, very large (known as the planck temperature) - it's not very conventient to calculate that. So instead of choosing the whoe range, we mapped a known area of it to a known area of it in the range. We are allowed to use an <code>ofMap()</code> for that, because the scale is linear. Some scales are not linear; For example, the decibel (<span class="math">\(\text{dB}\)</span>), commonly used in sound measurement, is logarithmic, so converting between a range of <span class="math">\(0_{\text{dB}}\)</span> - <span class="math">\(6_{\text{dB}}\)</span> to <span class="math">\(6_{\text{dB}}\)</span>-<span class="math">\(15_{\text{dB}}\)</span> would not convey any meaning.</li>
</ul>
<h4 id="range-utilities">Range Utilities</h4>
<h5 id="clamping">Clamping</h5>
<p>You'll notice that the previous explanation is missing the <code>clamp</code> parameter. This may not matter to us if we're using the <code>ofMap</code> function in the range that we defined, but suppose we select a <code>value</code> smaller than <code>inputMin</code>: would it be ok if the result was also smaller than <code>outputMin</code>? If our program is telling an elevator which floor to go to, that might be a problem. That's why we add <code>true</code> to the tail of this function whenever we need to be careful.</p>
<p>Just in case, oF offers another specific clamp function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofClamp(<span class="dt">float</span> value, <span class="dt">float</span> min, <span class="dt">float</span> max)</code></pre>
<h5 id="range-checking">Range Checking</h5>
<p>Two important functions we unjustly left out of this chapter:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> ofInRange(<span class="dt">float</span> t, <span class="dt">float</span> min, <span class="dt">float</span> max);</code></pre>
<p>Tells you whether a number <code>t</code> is between <code>min</code> and <code>max</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofSign(<span class="dt">float</span> n);</code></pre>
<p>Returns the sign of a number, as <code>-1.0</code> or <code>1.0</code>. Simple, eh?</p>
<h3 id="beyond-linear-changing-change">Beyond Linear: Changing Change</h3>
<p><strong>[mh: I recognize that you are trying to be general here by talking about change, but at least throwing the word motion around as a type of change would give readers something upon which to anchor the concept.]</strong></p>
<p>So far we've discussed change that is bound to a line. But in Real Life™ there's more than just straight lines.</p>
<p>The concept of change has many different applications in graphics and animation. For example, if we have a car moving at a steady pace along a straight road, we can describe its position using a <code>lerp</code> between the beginning and the end of the road. We also describe the car's speed that way, by saying it moves this (some number) much in that (some vector) direction:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Vector3 beginningOfRoad;
Vector3 endOfRoad;
<span class="dt">float</span> amountOfTravel;
<span class="co">//...</span>
ofLerp(beginningOfRoad, endOfRoad, amountOfTravel);</code></pre>
<p><strong>//TODO: finish this</strong></p>
<p>In this discussion, we're about to see how we can describe higher orders of complexity, via a cunning use of <code>lerp</code>s. Keep in mind that some of the code here is conceptual, not necessarily efficient.</p>
<h4 id="quadratic-and-cubic-change-rates">Quadratic and Cubic Change Rates</h4>
<p>Consider this function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> quadratic (<span class="dt">float</span> t){
	<span class="dt">float</span> a1 = ofLerp(t, <span class="dv">5</span>, <span class="dv">8</span>);
	<span class="dt">float</span> a2 = ofLerp(t, <span class="dv">2</span>, <span class="dv">9</span>);
	<span class="dt">float</span> b = ofLerp(t, a1, a2);
	<span class="kw">return</span> b;
	}</code></pre>
<p>This function used a defined range and a parameter to create <code>a1</code>, then used another defined range with the <em>same</em> parameter to create <code>a2</code>. Their result looks surprising:</p>
<p><strong>[GRAPHIC: QuadraticSpline.pdf to be processed]</strong></p>
<p>We've done something remarkable here. We used the way one parameter changes on two fixed lines to control a third, totally mobile line, and draw one point on it at each point in time between 0 and 1. In Mathspeak, it looks like this:</p>
<p><span class="math">\[
\begin{aligned}
\text{lerp}&amp;\left(t,\text{lerp}\left(t,5,8\right),\,\text{lerp}\left(t,2,9\right)\right) =\\
\text{lerp}&amp;\left(t,8\cdot t+5\cdot\left(1-t\right),9\cdot t+2\cdot\left(1-t\right)\right)\\
= &amp;\left(9\cdot t+2\cdot\left(1-t\right)\right)\cdot t+\left(8\cdot t+5\cdot\left(1-t\right)\right)\cdot\left(1-t\right)\\
= &amp;\left(9t^{2}+2t-2t^{2}\right)+\left(8t+5-5t\right)-\left(8t^{2}+5t-5t^{2}\right)\\
= &amp;4t^{2}+5
\end{aligned}
\]</span></p>
<p>Something interesting happened here. Without noticing, we introduced a second order of complexity, a <em>quadratic</em> one. Seriously, give it a second look, draw the entire process on paper. It's remarkable.</p>
<p>The same manipulation can be applied for a third order:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> cubic (<span class="dt">float</span> t){
	<span class="dt">float</span> a1 = ofLerp(t, <span class="dv">5</span>, <span class="dv">8</span>);
	<span class="dt">float</span> a2 = ofLerp(t, <span class="dv">2</span>, <span class="dv">9</span>);
	<span class="dt">float</span> a3 = ofLerp(t, <span class="dv">3</span>, -<span class="dv">11</span>);
	<span class="dt">float</span> a4 = ofLerp(t, -<span class="dv">2</span>, <span class="dv">4</span>);
	<span class="dt">float</span> b1 = ofLerp(t, a1, a2);
	<span class="dt">float</span> b2 = ofLerp(t, a3, a4);
	<span class="dt">float</span> c = ofLerp(t, b1, b2);
	<span class="kw">return</span> c;
	}</code></pre>
<p>We'll skip the entire solution, and just reveal that the result will appear in the form of <span class="math">\[at^{3} + bt^{2} + ct + d\]</span> See the pattern here? The highest exponent is the number of successive <code>ofLerp</code>s we applied, i.e. the number of times we nested the <code>lerp</code> function in itself.</p>
<h5 id="and-so-on">…And So On</h5>
<p>The general notion in Uni level Calculus is that <em>you can do anything if you have enough of something</em>. So fittingly, there's a curious little idea in Mathematics which allows us, with enough of these nested control points, to approximate any curve segment we can imagine. In the original formulation of that idea (called a <em>Taylor Series</em>), we only reach a good approximation if the amount of degrees (successive <code>lerp</code>s we applied) is close to infinity.</p>
<p>In Computer Graphics, as you're about to see - 3 is close enough.</p>
<h3 id="splines">Splines</h3>
<p>What we've done in the previous chapter is really quite remarkable. We have built a rig of points, on top of which we built a rig for controlling these points in pairs, and we continued to do so until we ended up with one parameter, <span class="math">\(t\)</span>, to control them all, subsequently controlling the process of drawing. In the domain we defined all of that to happen, we can clearly make this a physical metaphor: for example, a bunch of articulating sliderules connected to eachother at a certain point. However, for reasons you're about to see, Mathematicians will often shy away from the description of polynomials as a physical metaphor.</p>
<p>The reason is what happens to polynomials soon after they step away from their engineered control points. Outside the range of control, every polynomial will eventually go to infinity - which is a broad term, but for us designers it means that slightly off it's range, we'll need a lot more paper, or computer screen real estate, or yarn, or cockroaches (<a href="http://www.andrewcerrito.com/itpblog/itp-winter-show-nyc-food-crawl/">true story</a>) in order to draw it.</p>
<p><strong>[GRAPHICS: PolynomialToInfinity.pdf, to be processed]</strong></p>
<p>So instead of using polynomials the way they are, some mathematicians thought of a clever thing to do: use only the good range (one that's between the control points), wait for the polynomial to do something we don't like (like turn from positive to negative), <strong>then mix it with another polynomial</strong>. That actually works pretty well:</p>
<p><strong>[GRAPHICS: Spline.ai - Please talk to me before processing this]</strong></p>
<p>In the illustration, we've taken a few parts of the same cubic (3rd degree) polynomial, moved it around and scaled it to taste, and added all of them together at each point (let's call it 'mixing').</p>
<p>The resulting curve is seamless and easy to deal with. It also carries some sweet properties: using it, one can use the absolute minimum of direction changes to draw any cubic polynomial between any two points. <strong>[mh: maybe add another sentence here to unpack this]</strong> In other words, <em>it's smooth</em>.</p>
<p>These properties make this way of creating curves pretty popular in computer graphics, and you may find its variants under different names, like <em>Beziér Curves</em> or Spline Curves. The code for implementing this is a little long and tedious in C++, so this chapter won't go into it - but in case you were wondering, it's just the same code for making polynomials we discussed above, only with a lot of <code>if</code> statements to check if <code>t</code> is in the correct range.</p>
<p>Using the curve functions in openFrameworks is pretty straightforward: All you have to do is start from a point, and then add a destination, along with the control points <strong>[mh: worth defining a control point somewhere in here]</strong> to reach it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//The beginning point</span>
line.addVertex(ofPoint(<span class="dv">200</span>, <span class="dv">400</span>)); 
<span class="co">//A sequence of two control points and a destination: </span>
<span class="co">//control 1's x and y, control 2's x and y, and the destination</span>
line.bezierTo(<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">800</span>, <span class="dv">100</span>, <span class="dv">700</span>, <span class="dv">400</span>); </code></pre>
<p>This generates this image: <img alt="Beziér" src="images/bezier.png"/></p>
<p>This is just one example of use though. All of the different combinations are documented extensively in the <em>Advanced Graphics</em> chapter.</p>
<h3 id="tweening">Tweening</h3>
<p>So far we've learned how to use a bunch of control points to create an interesting curve in space. We've used our parameter <span class="math">\(t\)</span> to simulate the time it takes to draw each point on the curve. We also implicitly assumed that time runs only in the period that we let it run in, in the case of our examples, between 0 and 1. But we never really tested what it looks like to run all of that in real time.</p>
<p><strong>[GRAPHICS: Smoothstep.ai to be processed]</strong> The smoothstep function, <span class="math">\(f\left(x\right)=3x^{2} - 2x^{3}\)</span>, used to create a smooth transition between 0 and 1</p>
<p>Apparently, it's not that different from running it through space. By looking at the <span class="math">\(x\)</span> dimension of this graph as time and the <span class="math">\(y\)</span> dimension of this graph as a value for our creation, we can see some patterns of animation forming. The trick is simple: think of all of the values that need to change in your animation, and control them using functions.</p>
<p>Tweening is not yet a standard part of the openFrameworks library. In the meantime, some nice utility functions for tweening are available in the ofxTween library.</p>
<h2 id="more-dimensions-some-linear-algebra">More Dimensions: Some Linear Algebra</h2>
<p>Until now, we explored several ideas on how to change what's going on the number line. That's cool, but we want to know how to do graphics, and graphics has more than one dimension. Our ancient Mathematician ancestors (Just kidding, most important Mathematicians die before 30. Not kidding) also faced this problem when trying to address the space of shapes and structures, and invented some complex machinery to do so. The fancy name for this machinery is <em>Linear Algebra</em>, which is exactly what it sounds like: using algebraic operations (add and multiply, mostly), in order to control many lines.</p>
<p>In this part you're going to learn many concepts in how to store and manipulate multidimensional information. You'll later be able to use that information to control realtime 3d graphics using OpenGL, and impress the opposite (or same) sex with your mastery of geometry.</p>
<h3 id="the-vector">The Vector</h3>
<p>You may have heard of vectors before when discussing directions or position, and after understanding that they can represent both, may have gotten a little confused. Here's the truth about Vectors™:</p>
<blockquote>
<p>A vector is just an array that stores multiple pieces of the same type of information.</p>
</blockquote>
<p>Seriously, that's all it is. Quit hiding.</p>
<p>This simplicity is also their great power. Just like the number 5 can be used to describe five Kilometres, the result of subtracting 12 and 7, or the number of cookies in a jar - the same works with vectors.</p>
<p>It's up to the user of that mathematical object to choose what it is used as. The vector <span class="math">\[v=\left[\begin{array}{c}5\\-3\\1\end{array}\right]\]</span> can represent a point in space, a direction of a moving object, a force applied to your game character, or just three numbers. And just like with numbers, algebraic operations such as addition and multiplication may be applied to vectors.</p>
<p>Oh, but there's a catch. You see, everyone was taught what <span class="math">\(a + b\)</span> means. In order to go on with vectors, we need to define that.</p>
<h4 id="vector-algebra">Vector Algebra</h4>
<p>Generally speaking, when dealing with Algebra of numerical structures that aren't numbers, we need to pay close attention to the <em>type</em> of things we're cooking together. In the case of vectors, we'll make a distinction between <em>per-component</em> and <em>per-vector</em> operations.</p>
<h5 id="scalar-multiplication">Scalar Multiplication</h5>
<p>The product between a vector and a scalar is defined as:</p>
<p><span class="math">\[a\left[\begin{array}{c}
x\\
y\\
z
\end{array}\right]=\left[\begin{array}{c}
ax\\
ay\\
az
\end{array}\right]\]</span></p>
<p>That falls into the category of <em>per-vector</em> operations, because the entire vector undergoes the same operation. Note that this operation is just a scaling.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofVec3f a(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);
cout &lt;&lt; ofToString( a * <span class="dv">2</span> ) &lt;&lt; endl; 
<span class="co">//prints (2,4,6)</span></code></pre>
<h5 id="vector-addition">Vector Addition</h5>
<p>Adding vectors is pretty straightforward: it's a <em>per-component</em> operation:</p>
<p><span class="math">\[\left[\begin{array}{c}
x_{1}\\
y_{1}\\
z_{1}
\end{array}\right]+\left[\begin{array}{c}
x_{2}\\
y_{2}\\
z_{2}
\end{array}\right]=\left[\begin{array}{c}
x_{1}+x_{2}\\
y_{1}+y_{2}\\
z_{1}+z_{2}
\end{array}\right]\]</span></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofVec3f a(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>);
ofVec3f b(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>);
cout &lt;&lt; ofToString( a + b ) &lt;&lt; endl; 
<span class="co">//prints (14,25,36)</span></code></pre>
<h6 id="example-ofvec2f-as-position">Example: <code>ofVec2f</code> as position</h6>
<p>Vector addition serves many simple roles. In this example, we're trying to track our friend Lars as he makes his way home from a pub. Trouble is, Lars is a little drunk. He knows he lives south of the pub, so he ventures south; But since he can't walk straight, he might end up somewhere else.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* in testApp.h: */</span>
ofVec2f larsPosition;
<span class="dt">void</span> larsStep(ofVec2f direction);

<span class="co">/* in testApp.cpp: */</span>
<span class="dt">void</span> testApp::setup(){
	larsPosition = ofVec2f( ofGetWidth() / <span class="dv">2</span>., ofGetHeight() / <span class="dv">3</span>. );
}

<span class="dt">void</span> testApp::update(){
	<span class="kw">if</span> (larsPosition.y &lt; ofGetHeight * <span class="dv">2</span>. / <span class="dv">3</span>.){
		<span class="co">//As Lars attempts to take one step south,</span>
		<span class="co">//He also deviates a little to the right, </span>
		<span class="co">//or a little to the left. </span>
		ofVec2f nextStep(ofRandom(-<span class="dv">1</span>.,<span class="dv">1</span>.),<span class="dv">1</span>.); 
		larsStep(nextStep);
	}

<span class="dt">void</span> ofApp::larsStep(ofVec2f direction){ 
	position += direction; 
}

<span class="dt">void</span> testApp::draw(){ 
	<span class="co">//Draw Lars any way you want. No one's judging you.</span>
}</code></pre>
<h5 id="note-c-operator-overloading">Note: C++ Operator Overloading</h5>
<p><strong>[mh: this proke the flor a bit for me, so I'd recommend pushing it later]</strong></p>
<p>Just like we had to define the meaning of a product of a scalar quantity and a vector, programming languages - working with abstract representations of mathematical objects, also need to have definitions of such an operation built in. C++ takes special care of these cases, using a feature called <em>Operator Overloading</em>: defining the <code>*</code> operation to accept a scalar quantity and a vector as left-hand side and right-hand side arguments:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofVec3f <span class="kw">operator</span>*( <span class="dt">float</span> f, <span class="dt">const</span> ofVec3f&amp; vec ) {
    <span class="kw">return</span> ofVec3f( f*vec.x, f*vec.y, f*vec.z );
}</code></pre>
<p>The same is defined, for example, between two instances of <code>ofVec3f</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofVec3f ofVec3f::<span class="kw">operator</span>+( <span class="dt">const</span> ofVec3f&amp; pnt ) <span class="dt">const</span> {
	<span class="kw">return</span> ofVec3f( x+pnt.x, y+pnt.y, z+pnt.z );
}</code></pre>
<p>naturally representing the idea of vector addition.</p>
<p>The basic arithmetic operations, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, exist for both combinations of <code>ofVec2f</code>, <code>ofVec3f</code> and <code>ofVec4f</code>s and between any vector object and a scalar quantity. Whenever an operation is postfixed with <code>=</code>, it modifies the left-hand side with the operation, <em>and only then</em>. The operations <code>+</code>,<code>-</code>,<code>*</code>,<code>/</code> will <em>always</em> return a copy.</p>
<p>Some excellent examples of operator overloading done right exist in the source files for the <code>ofVec</code> types. It's encouraged to check them out.</p>
<p><strong>Warning: Overloading operators will make you go blind.</strong> Programmers use operators without checking what they do, so bugs resulting from bad overloads take a long time to catch. If the expression <code>a + b</code> returns a reference instead of a copy, a <code>null</code> instead of a value, or modifies one of the input values – someone will use it one day, and that someone will cry for many days. Unless the operator can do one arithmetic thing and that alone, do not overload it with a different meaning. openFrameworks may or may not have a feature that tweets for you whenever you've written a silly operator overload. <a href="https://code.google.com/p/keytweeter/">No one knows</a>.</p>
<h5 id="distance-between-points">Distance Between Points</h5>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofVec3f::distance( <span class="dt">const</span> ofVec3f&amp; pnt) <span class="dt">const</span>
<span class="dt">float</span> ofVec3f::squareDistance( <span class="dt">const</span> ofVec3f&amp; pnt ) <span class="dt">const</span>
<span class="dt">float</span> ofVec3f::length() <span class="dt">const</span>
<span class="dt">float</span> ofDist(<span class="dt">float</span> x1, <span class="dt">float</span> y1, <span class="dt">float</span> x2, <span class="dt">float</span> y2);
<span class="dt">float</span> ofDistSquared(<span class="dt">float</span> x1, <span class="dt">float</span> y1, <span class="dt">float</span> x2, <span class="dt">float</span> y2);</code></pre>
<p>Let's start by a definition. You may remember the <em>Pythagorean Theorem</em>, stating what the length of a line between point <span class="math">\(a\)</span> and <span class="math">\(b\)</span> is: <span class="math">\[\text{Distance}\left(\left[\begin{array}{c}
x_{a}\\
y_{a}
\end{array}\right],\left[\begin{array}{c}
x_{b}\\
y_{b}
\end{array}\right]\right)=\sqrt{\left(x_{b}-x_{a}\right)^{2}+\left(y_{b}-y_{a}\right)^{2}}\]</span></p>
<p>Here's the good news: It's the exact same definition in three dimensions! just add the <span class="math">\(z\)</span> term. <span class="math">\[\text{Distance}\left(\left[\begin{array}{c}
x_{a}\\
y_{a}\\
z_{a}
\end{array}\right],\left[\begin{array}{c}
x_{b}\\
y_{b}\\
z_{b}
\end{array}\right]\right)=\sqrt{\left(x_{b}-x_{a}\right)^{2}+\left(y_{b}-y_{a}\right)^{2}+\left(z_{b}-z_{a}\right)^{2}}\]</span></p>
<p>Vector Length, then, can be naturally defined as the distance between the vector and the point <span class="math">\(\left(0,0,0\right)\)</span>: <span class="math">\[\text{Length}\left(\left[\begin{array}{c}
x\\
y\\
z
\end{array}\right]\right)=\sqrt{x^{2} + y^{2} + z^{2}}\]</span></p>
<p>And that's exactly what using <code>.length()</code> as a property of any <code>ofVec</code> will give you.</p>
<h5 id="vector-products-theres-more-than-one">Vector Products: There's More Than One</h5>
<p>So you're multiplying two numbers. Simple, right? Five million and seven times three equals something you know. Even if you need a calculator for the result, you still know <em>it's a number</em> that's not the case with vectors. If we just want to resize vectors (the way we do with numbers), we multiply a vector by a scalar and it grows. But what does it mean, geometrically, to multiply by a vector?</p>
<p>If we were to follow the <em>per-component</em> convention that we created, we would get an operation like this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">cout &lt;&lt; ofToString(ofVec3f(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) * ofVec3f(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)) &lt;&lt; endl;
<span class="co">//prints (1,4,9)</span></code></pre>
<p>It's also known as the <em>Hadamard product</em>. It's intuitive, but not particularly useful. One case it is useful for is if we want to scale something individually in every dimension.</p>
<p>In the next section we describe something more helpful.</p>
<h5 id="the-dot-product">The Dot Product</h5>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ofVec3f::dot( <span class="dt">const</span> ofVec3f&amp; vec )</code></pre>
<p>The dot product of two vectors has a definition that's not too clear at first. On one hand, the operation can be defined as <span class="math">\[v_{a}\bullet v_{b}=x_{a}\cdot x_{b}+y_{a}\cdot y_{b}+z_{a}\cdot z_{b}\]</span> which is really easy to implement (in fact, graphics cards have special circuitry for doing just that!). On the other hand, it can also bet defined as <span class="math">\[v_{a}\bullet v_{b}=\left\Vert v_{a}\right\Vert \cdot\left\Vert v_{b}\right\Vert \cdot\cos\theta\]</span> where <span class="math">\(\theta\)</span> is the angle between the two vectors. Soon you'll see that this is a rather lucky coincidence. In the meantime, here's how you <em>shoud</em> remember dot products:</p>
<blockquote>
<p>A dot product of <span class="math">\(a\)</span> and <span class="math">\(b\)</span> reflects how one vector projects in the other vector's direction.</p>
</blockquote>
<p>Hold it. That's not the end of the story. As you can see, the <span class="math">\(\left\Vert v_{a}\right\Vert \cdot\left\Vert v_{b}\right\Vert\)</span> part of <span class="math">\(\left\Vert v_{a}\right\Vert \cdot\left\Vert v_{b}\right\Vert \cdot\cos\theta\)</span> should tell you that both vectors' lengths have equal parts in determining the final size of the thing, but in most practical cases, you'll be using dot products to determine either vector length or angles between vectors.</p>
<p>That's why dot products are such an amazing coincidence: If you know the lengths of <span class="math">\(v_{a}\)</span> and <span class="math">\(v_{b}\)</span>, you're given <span class="math">\(\cos\theta\)</span> for free. If you know the plane on which <span class="math">\(v_{a}\)</span> and <span class="math">\(v_{b}\)</span> lie, one vector and the angle to the other, you get the other one for cheap, and so on. In typical use, if we were to take two vectors that each have length 1 (<em>normalized</em> vectors, in Mathspeak), the dot product <span class="math">\(a⋅b\)</span> would basically a cosine of the angle between them. That relationship, described by <span class="math">\(\cos\theta\)</span>, is easy to think of as a projection: Imagine shining a light from the top of one axis, and observing the shadow on another axis. How long it is, and which direction it's going, is exactly consistent with the dot product (in fact, most lighting models use dot products for just about everything).</p>
<h5 id="example-finding-out-if-a-point-is-above-or-below-a-plane">Example: Finding out if a point is above or below a plane</h5>
<p>This is a problem we'll often run into in 3D graphics: given a point <span class="math">\(p\)</span> and a plane, we need to figure out which side of the plane the point is on. This may be really useful if you're trying to decide what <em>not</em> to render in a scene, in order to save processing time.</p>
<p>There are many equivalent ways to describe a plane. The most elegant one in this case is by using the plane's normal (the direction perpendicular to both axis of the plane) which is a vector we'll mark as <span class="math">\(n\)</span>, and the distance from the origin, <span class="math">\(d\)</span> (note that because the plane can pass below the origin, this distance can be negative). This is a valid definition: a plane can be defined as all of the points in the world that form a perpendicular vector to the normal.</p>
<p>Now the math:</p>
<p><strong>If the point <span class="math">\(p\)</span> is on the plane.</strong> We know that every line on the plane is perpendicular to (has a 90-degree angle with) the normal. Specifically, every line connecting some point on a plane to the point where we put our normal (which is the same on the plane) so if we extract the direction vector from the line and call it <span class="math">\(v\)</span>, we can say: <span class="math">\[n∙v = \left\Vert n\right\Vert ⋅\left\Vert v\right\Vert ⋅\cos90^{\circ} = \left\Vert n\right\Vert ⋅\left\Vert v\right\Vert ⋅0 = 0\]</span>.</p>
<p><strong>If the point <span class="math">\(p\)</span> isn't on a plane.</strong> In that case we know that it definitely doesn't have a 90-degree angle with the plane's normal <span class="math">\(n\)</span>, therefore the dot product <span class="math">\(n\bullet v\)</span> won't be zero. So all we need to know is: does it project on the normal's positive direction, or it's negative direction? In order to do that, we first find a point on the plane. That's easy, we defined our plane such that we can follow the normal <span class="math">\(n\)</span> from the origin <span class="math">\(\left(0,0,0\right)\)</span> for a length <span class="math">\(d\)</span> and we'll get there.</p>
<p>Therefore the point <span class="math">\(q = d⋅n\)</span> is most definitely on the plane.</p>
<p>Now, let's make up a vector from the point <span class="math">\(p\)</span> to that point: <span class="math">\(v = q - p\)</span>. This equation holds because when subtracting two points, we get the difference between them, hence the direction from <span class="math">\(p\)</span> to <span class="math">\(q\)</span>. Now we calculate: <span class="math">\[v∙n = v_{x}⋅n_{x}+v_{y}⋅n_{y}+v_{z}⋅n_{z}\]</span></p>
<ul>
<li><em>If the dot product is positive</em>, the normal and the line to a point on the plane are both pointing in the same direction, that means that the point <span class="math">\(p\)</span> is <em>below</em> the plane.</li>
<li><em>If the dot product is negative</em>, the line from the point to the plane has to go back, therefore the point is above the plane.</li>
</ul>
<p>Here's the code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//we define a margin for numerical error</span>
<span class="dt">float</span> <span class="dt">const</span> EPSILON = <span class="fl">0.00001</span>;

<span class="co">// a function that returns -1 if a point is below a plane,</span>
<span class="co">// 1 if it's above a plane and 0 if it's on a plane</span>
<span class="dt">int</span> whichSide(ofVec3f planeNormal, <span class="dt">float</span> planeDistance, ofVec3f testPoint){
	ofVec3f directionToPlane = planeDistance * planeNormal - testPoint;
	<span class="dt">float</span> dot = directionToPlane.dot(planeNormal);
	<span class="kw">if</span> (abs(dot) &lt; EPSILON){ <span class="co">//Check if the dot product is very near zero </span>
		<span class="kw">return</span> <span class="dv">0</span>;
	} <span class="kw">else</span> { <span class="co">// else return the opposite of its sign!</span>
	<span class="kw">return</span> (dot &lt; <span class="dv">0</span> ? <span class="dv">1</span> : -<span class="dv">1</span>);
	}
}</code></pre>
<p>Note that in the code we had to take care of numerical inaccuracy of the computer, and give it a margin for deciding that a vector is sometimes perpendicular to that normal. An alternative would be to ignore those cases, and chose that anything with <code>dot &gt; 0</code> is below the plane. I like it better this way.</p>
<p>As you can see from the example, the dot product is magical: just from knowing the coordinates, we get an insight about the angle between vectors for free.</p>
<h3 id="the-matrix">The Matrix™</h3>
<p>In the computer world, a program needs the two things to function: Algorithms and Data Structures (it also needs I/O, but we're talking about computation, not engineering). In the 3D Maths world it's exactly the same: we call our data structures 'vectors' and our algorithms are operations.</p>
<p>At the core of the heavy machinery built to control 3d space, a matrix is just a data structure, like a vector. However, the 'algorithms' applied to this data structure (operations, in Mathland) make it an extremely powerful one. All of the <em>affine</em> operations we care about in 3D can be described in the form of a matrix: translation, rotation, scaling, inversion, squeezing, shearing, projection and more and more. Here's a simple way to remember this:</p>
<blockquote>
<p>A Matrix is a mathematical object that stores a geometric transformation of points.</p>
</blockquote>
<p><strong>Notation Convention:</strong> When dealing with matrices, most authors usually mark vectors with lowercase letters and matrices with uppercase letters.</p>
<h4 id="matrix-multiplication-as-a-dot-product">Matrix Multiplication as a dot product</h4>
<p>The easiest way to look at a matrix is to look at it as a bunch of vectors. Depending on what we care about, we can either look at the columns or rows as vectors.</p>
<p><strong>//TODO: Draw 2x2 example</strong></p>
<h5 id="identity">Identity</h5>
<p>Let's start from the simplest case. Just like with numbers, it is a very important property of any algebraic structure to have a <em>neutral</em> member for each operation. For example, in Numberland, multiplication of any <span class="math">\(x\)</span> by 1 returns <span class="math">\(x\)</span>, same goes for addition to 0. In Matrixland, that identity element is a matrix with 1s along the diagonal zeroes elsewhere. For example, the identity matrix for 3 dimensions is:</p>
<p><span class="math">\[I_{3} = \left[\begin{array}{ccc}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{array}\right]\]</span></p>
<p>So for any matrix <span class="math">\(M\)</span>, <span class="math">\[MI = IM = M\]</span>.</p>
<p><strong>Note:</strong> You may have noticed that we're very careful right now with the order of multiplications, like when we took extra care to describe that <span class="math">\(MI = IM\)</span>. There's a good reason for that, and you'll discover it in a few pages.</p>
<h5 id="scale">Scale</h5>
<p>You might remember that when scaling a vector (i.e point in space and/or velocity and/or force and/or brightness value for a colour, etc), we may choose to scale it uniformly by scalar multiplication <strong>/* TODO:Example */</strong> or, because of a weird language design choice, most graphics applications will allow you to scale non-uniformly on a per-component basis: <strong>/* TODO:Example */</strong></p>
<p>To put an end to this insanity, scaling in matrix multiplication is well-defined (<em>sidenote</em>: well defined means blah blah) in openFrameworks (also in math!). It goes like this: The matrix <span class="math">\(S\)</span> that scales <span class="math">\(\left(x,y,z\right)^{T}\)</span> to <span class="math">\(\left(ax,by,cz\right)^{T}\)</span> is: <span class="math">\[S\cdot \left[\begin{array}{c}
x\\
y\\
z
\end{array}\right]=\left[\begin{array}{ccc}
a &amp; 0 &amp; 0\\
0 &amp; b &amp; 0\\
0 &amp; 0 &amp; c
\end{array}\right]
\cdot \left[\begin{array}{c}
x\\
y\\
z
\end{array}\right] = 
\left[\begin{array}{c}
ax\\
by\\
cz
\end{array}\right]\]</span></p>
<p>There's logic behind this. Recall that a vector multiplied by a matrix, <span class="math">\(M\cdot v\)</span> is just a collection of dot products: <span class="math">\[
M\cdot v=\left[\begin{array}{c}
M_{1}\\
M_{2}\\
M_{3}
\end{array}\right]\cdot v=\left[\begin{array}{c}
\begin{array}{c}
M_{1}\cdot v\\
M_{2}\cdot v\\
M_{3}\cdot v
\end{array}\end{array}\right]
\]</span></p>
<p><strong>//TODO: Improve this</strong></p>
<p>So, in order to get a multiplication through that only affects <span class="math">\(x\)</span>, we tune the vector (upper row of the matrix) <span class="math">\(M_{1}\)</span> to be zero anywhere but the interface with <span class="math">\(x\)</span>: <span class="math">\[M_{1} = \left(a,0,0\right)\]</span> so the entire calculation would be:</p>
<p><span class="math">\[
M\cdot v=\left[\begin{array}{c}
M_{1}\\
M_{2}\\
M_{3}
\end{array}\right]\cdot v=
\left[\begin{array}{ccc}
a &amp; 0 &amp; 0\\
M_{2,1} &amp; M_{2,2} &amp; M_{2,3}\\
M_{3,1} &amp; M_{3,2} &amp; M_{3,3}
\end{array}\right]\cdot v=\left[\begin{array}{c}
\begin{array}{c}
a\cdot v_{x} + 0\cdot v_{y} + 0\cdot v_{z}\\
M_{2,1}\cdot v_{x} + M_{2,2}\cdot v_{y} + M_{2,3}\cdot v_{z}\\
M_{3,1}\cdot v_{x} + M_{3,2}\cdot v_{y} + M_{3,3}\cdot v_{z}
\end{array}\end{array}\right]
\]</span> Making the <span class="math">\(x\)</span> component of the resulting vector be <span class="math">\(a\cdot v_{x}\)</span>, just as promised.</p>
<p>Scalar multiplication of any matrix <span class="math">\(M\)</span> becomes really easy, then: it's essentially right multiplication by a diagonal matrix full of <span class="math">\(a\)</span>'s: <span class="math">\[a\cdot M = a \cdot I \cdot M\]</span></p>
<h5 id="skew-matrices">Skew matrices</h5>
<p><strong>[mh: this could use an image]</strong></p>
<p>Odd operations like skewing are where things need to get a little less intuitive and more logical. When we think of <em>skewing</em> we normally imagine adding to a certain dimension, suppose <span class="math">\(x\)</span>, a proportion of a quantity from another dimension, let's say <span class="math">\(y\)</span>. Suppose that proportion is some <span class="math">\(0 &lt; a \leq 1\)</span>, as if to say, 'I want to nudge it a little, the more it leaves the ground'. The matrix for doing that in 2 dimensions would look like this: <span class="math">\[S = \left[\begin{array}{cc} 
1 &amp; a\\
0 &amp; 1 
\end{array}\right]\]</span> See what we did there? We made the resulting <span class="math">\(x\)</span> value depend on the input <span class="math">\(x\)</span> value (being multiplied by 1), but also slightly depend on the input <span class="math">\(y\)</span>, exactly how slightly being determined by the magnitude of <span class="math">\(a\)</span>:</p>
<p><span class="math">\[S\cdot v = \left[\begin{array}{cc} 
1 &amp; a\\
0 &amp; 1 
\end{array}\right]
\left[\begin{array}{c}
x\\
y\end{array}\right] = 
\left[\begin{array}{c}
1\cdot x + a\cdot y\\
0\cdot x + 1 \cdot y\end{array}\right] = 
\left[\begin{array}{c}
x + ay\\
y\end{array}\right]\]</span></p>
<p>Pretty neat, right? Try to remember this trick, as we're going to use it quite a lot when we move stuff around in the fourth dimension. I'm not even joking.</p>
<h5 id="rotation-matrices">Rotation matrices</h5>
<p>We now see that any operation in Matrixland can really be expressed in a collection of vectors. We also know that dot products of vectors express the angle between two vectors times their magnitude. A slightly surprising fact is that those two properties are enough to describe any rotation.</p>
<p>In order to comprehend this last statement, let's first explain how rotating one vector works. Let's suppose for now our vector has length 1 (it's generally a good thing to start from, as it is then neutral to scaling), and that we would like to rotate the vector by an angle <span class="math">\(\theta\)</span>, starting from a point on the x axis. The rotated vector would be <span class="math">\[v_{\theta}=\left[\begin{array}{c}
\cos\theta\\
\sin\theta
\end{array}\right]\]</span></p>
<p>Now we found a target for the <span class="math">\(x\)</span> axis to go to. In order to find a new home for the old <span class="math">\(y\)</span> axis, we only need to know the angle between them. Luckily, we all know that it's 90 degrees, or in radians: <span class="math">\(\frac{\pi}{2}\)</span>. The new home will then have to be at angle <span class="math">\(\theta + \frac{\pi}{2}\)</span> from the x axis (angle 0):</p>
<p><span class="math">\[
y_{\theta}=\left[\begin{array}{c}
\cos\left(\theta+\frac{\pi}{2}\right)\\
\sin\left(\theta+\frac{\pi}{2}\right)
\end{array}\right] = \left[\begin{array}{c}
-\sin\theta\\
\cos\theta
\end{array}\right]
\]</span></p>
<p>That last equality is due to trigonometric equalities.</p>
<h6 id="d-rotation-matrices">2D Rotation Matrices</h6>
<p>We now have all of the information we need to build a matrix that moves the vectors <span class="math">\(\left\{ \left[\begin{array}{c} 1\\ 0 \end{array}\right],\left[\begin{array}{c} 0\\ 1 \end{array}\right]\right\}\)</span> to <span class="math">\(\left\{ \left[\begin{array}{c} \cos\theta\\ \sin\theta \end{array}\right],\left[\begin{array}{c} -\sin\theta\\ \cos\theta \end{array}\right]\right\}\)</span> :</p>
<p><strong>//TODO: Write a 2D rotation matrix</strong></p>
<p>Now, hold on. Check out what we did here: we placed the targets for the source vectors as <em>columns</em> in the matrix, and then we took the resulting <em>rows</em> of the matrix to do the rotation. Why did we do that?</p>
<p>Recall that a matrix is just a stack of dot products. How did we construct these dot products? We just aligned all of the entries that should be affecting the <em>resulting</em> entry in one row of the matrix. That means that when considering the resulting <span class="math">\(y\)</span> entry, our vectors defined <em>the mixture of <span class="math">\(y\)</span> components</em> from the target vectors that we would like to see in the resulting operation. This makes sense: Think of the vectors that compose the matrix as a new coordinate system, and what we're calculating is how the 'natural' coordinate system is projected onto them.</p>
<h5 id="d-rotation-matrices-1">3D Rotation Matrices</h5>
<p>In <em>Flatland</em>, Edwin A. Abbott describes a land in which two-dimensional beings live obliviously and happily, until one of them encounters a three-dimensional thing. His mind is boggled – he quickly understands the implications; When he tries to explain it to the other squares living in his world, they are apalled and he is cast away as a heretic.</p>
<p>Rotation in three dimensions is more complex to understand than rotations in two dimensions. There are much more cases, and in order to understand nontrivial rotations, one has to actually look at things in four dimensions. This seems to anger many people who don't normally think in 4 dimensions. After all we've been through, please stick around for this one too.</p>
<h6 id="euler-angles">Euler Angles</h6>
<p>The easiest way to think about rotations in 3D is to just think about them as a series of 2D-rotations. Let's called that <em>nesting a dimension</em>.</p>
<p>The trick for rotating about one axis in 3D-land works the exact same way it does in 2d land: In order to rotate around one axis, all we need to do is to use a 2d rotation matrix (think about it: a rotation about one axis doesn't depend on the others just yet), and add a neutral dimension to it. Here's what rotation matrices in 3d look like when we use one axis of rotation each time:</p>
<p><span class="math">\[\begin{aligned}
R_{x}(\theta) &amp;= \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \theta &amp;  -\sin \theta \\
0 &amp; \sin \theta  &amp;  \cos \theta \\
\end{bmatrix}\\ 
R_{y}(\theta) &amp;= \begin{bmatrix}
\cos \theta &amp; 0 &amp; \sin \theta \\
0 &amp; 1 &amp; 0 \\[3pt]
-\sin \theta &amp; 0 &amp; \cos \theta \\
\end{bmatrix} \\
R_{z}(\theta) &amp;= \begin{bmatrix}
\cos \theta &amp;  -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta &amp; 0\\
0 &amp; 0 &amp; 1\\
\end{bmatrix}
\end{aligned}
\]</span></p>
<p>And this is indeed a useful way for rotating about one axis. Leonhard Euler, a famous Mathematician working on these types of rotations, noted early on that while good for rotating about one axis, this method (later named after him) was not trivial to state for multiaxial rotations. To understand that, it's easiest to grab a Rubik's cube and twist it about its <span class="math">\(x\)</span> dimension, and then about it's <span class="math">\(y\)</span> dimension. Now make a note of where the unique tiles have moved, revert the changes, and try it again with first <span class="math">\(y\)</span> and then <span class="math">\(x\)</span>. Your results will be different!</p>
<p>Noting that, we know that when rotating things in more than 2 dimensions, we need to know not only the angles of the rotations, but the order in which to apply them. The rotation matrices <span class="math">\(R_{zx}\left(\theta\right) = R_{z}\left(\theta\right)⋅R_{x}\left(\theta\right)\)</span> and <span class="math">\(R_{xz}\left(\theta\right) = R_{x}\left(\theta\right)⋅R_{z}\left(\theta\right)\)</span> are not the same. The reason for the difference will be explained in the next section.</p>
<h6 id="other-methods-of-rotation-axis-angles-and-quaternions">Other Methods of Rotation: Axis-Angles and Quaternions</h6>
<p>We can only end this one-page section with a defeating note: rotations in 3D are a big subject. Even though one matrix can only mean one thing, there are multiple ways of getting to it. Euler Angles demonstrated above are one common and easy-to-comprehend way; A slightly more general way is given by defining an arbitrary axis and rotating around it, called <em>Axis-Angle Rotation</em>.</p>
<p><strong>//TODO: Draw difference between angle-axis and normal-axis euler rotations </strong></p>
<p>Constructing the matrix for that kind of rotation is slightly hairy, which is why programmers often prefer not to use matrices for describing those rotations, but more compact Algebraic objects called <em>Quaternions</em>. Those exist in openFrameworks under <code>ofQuaternion</code>, and can mostly be used without actually investigating the underlying math.</p>
<p>As far as usage goes, it's important to note that Quaternions are sometimes more efficient (and actually easier to think with) than Matrices, but their Mathematical underpinnings are far beyond the scope of a basic math chapter.</p>
<h4 id="matrix-algebra">Matrix Algebra</h4>
<p>This chapter introduced a different kind of math from what you were used to. But while introducing <em>a new thing to do things with</em> we opened up a lot of unexplored dangers. Notice that we always multiplied vectors by matrices in a certain order: It's always the vector <em>after</em> the matrix, the vector is always transposed, and any new operation applied to an existing situation always happens with a matrix to the left of our result. There's a reason for all of that: <em>Commutativity</em>.</p>
<h5 id="commmumamitativiwha">Commmumamitativiwha?</h5>
<p>In high school Algebra, we used to think that <span class="math">\(a\cdot b=b\cdot a\)</span>. No reason not to think that: The amount of uranium rods that you have times the amount of specially trained monkeys that I have equals the same amount of casualties, no matter the order of multiplication. That's because quantities are <em>commutative</em>, the order in which they apply operations to each other doesn't matter.</p>
<p>But, in matrixland we're not talking about things we counted - instead, we're talking about operations, and here's the deal:</p>
<blockquote>
<p>Operations (like Rotation, Translation and Scaling) are generally not commutative.</p>
</blockquote>
<p>There's a difference between scaling a square by x and then rotating it by 90 degrees and doing it the other way around:</p>
<p><strong>//TODO: Draw this</strong></p>
<p>What's more, doing it the other way around is not always defined. Matrices and vectors with unequal sizes have very special conditions in which they could be multiplied. We're not dealing with them now, so I'll let you read about it in Wikipedia, but it's important to know that whenever using matrices for manipulating a space, order of operands is really important.</p>
<h5 id="what-else-is-weird">What else is weird?</h5>
<p><strong>Nothing.</strong> We can still multiply the matrices and vectors in any order that we want to: <span class="math">\[M_{1}⋅M_{2}⋅v = \left(M_{1}⋅M_{2}\right)⋅v = M_{1}⋅\left(M_{2}⋅v\right)\]</span> as long as we don't change the order in which they appear. That property is called <em>Associativity</em>, and it's one of the defining properties of algebraic structures that describe geometric operations, structures which mathematicians call <em>Groups</em>. <em>Commutativity</em> is an optional property for groups, it just happens to be a given when dealing with operations between numbers, which is why you've never been told that you need it. There's a lesson here: simulations take a lot of properties for granted. It's sometimes good to ask why.</p>
<p>Now grab a pack of ice, place it on your head for 15 minutes and go on reading the next part.</p>
<h3 id="the-full-stack">"The Full Stack"</h3>
<p>Now that we know how to construct its major components, let's have a look at all the math that constructs graphics in openFrameworks before sending it to the screen. For that, we'll have to – once again – increase our number of D's.</p>
<h4 id="translation-matrices">Translation matrices</h4>
<p>If you recall the comment in the beginning of this chapter, mathematicians are very careful when calling things linear. In 2D, a linear operation can basically do 2 things: Rotation and Scaling (including negative scaling - "mirroring"). The reason for this is that these are all operations that can be done in n dimensions to any n-dimensional shape (replace n with 3 for our example).</p>
<p>If the entire shape lifts itself magically and moves away from the origin - it can't be done with a matrix, therefore it's not linear. This presents a problem to people who want to use matrices as an algebraic system for controlling 3d: in real life we need to move some stuff around.</p>
<h5 id="homogenous-coordinates-hacking-3d-in-4d">Homogenous coordinates: Hacking 3d in 4d</h5>
<p>This problem has caused hundreds of years of agony to the openFrameworks community, until in 1827 a hacker called Möbius pushed an update to the ofMäth SVN repo: use the matrix in 4 dimensions to control a 3 dimensional shape. Here's the shtick: a 3d operation can be described as a 4d operation which doesn't do anything to the 4th dimension. Written as a matrix, we can describe it like this:</p>
<p><span class="math">\[ A _{4\times 4} = \left[\begin{array}{ccc|c}
a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; 0\\
a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; 0\\
a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; 0\\
\hline 0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]\]</span></p>
<p>Now we already know that a 1D Skew can move all lines in that axis in a certain direction without affecting the other dimensions, and that a 2D skew will do that for all things on a certain plane, so it's easy to imagine that a 3D skew will do that to 3D spaces embedded in a space with more dimension. Möbius figured that feature is useful, and he proposed on the bianual openFrämeworks meeting in Tübingen that all operations will be conducted in 4D space, and then projected back into 3D space, like this:</p>
<p><span class="math">\[T = \left[\begin{array}{ccc|c}
1 &amp; 0 &amp; 0 &amp; t_{x}\\
0 &amp; 1 &amp; 0 &amp; t_{y}\\
0 &amp; 0 &amp; 1 &amp; t_{z}\\
\hline 0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]\]</span></p>
<p>The 3D Transform vector <span class="math">\(t\)</span> is placed in the 4th dimension, with it's 4th entry as 1 (because 1 is neutral to multiplication). The bottom row that is added has zeroes in the <span class="math">\(x,y,z\)</span> entries, in order to avoid interfering with other operations. Check out what happens when a vector is multiplied by this matrix:</p>
<p><span class="math">\[T\cdot v = \left[\begin{array}{ccc|c}
1 &amp; 0 &amp; 0 &amp; t_{x}\\
0 &amp; 1 &amp; 0 &amp; t_{y}\\
0 &amp; 0 &amp; 1 &amp; t_{z}\\
\hline 0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]\cdot\left[\begin{array}{c}
x\\
y\\
z\\
\hline 1
\end{array}\right]=\left[\begin{array}{c}
x+t_{x}\\
y+t_{y}\\
z+t_{z}\\
\hline 1
\end{array}\right]\]</span></p>
<p>Now all we need to do is discard the 4th dimension to get our translated point. Quite cool, innit?</p>
<p>Notice that because we placed a 1 at the <span class="math">\(w\)</span> (4th) dimension, all of the multiplication operations went through that component transparently. This trick became the standard of most computer geometry systems. Möbius actually has a lot more going in this theory: if we change that 1 into something else, we're able to simulate a projection into a camera pinhole. This chapter won't cover that fascinating part of math, but when you get to building cameras in OpenGL, keep this amazing hack in mind.</p>
<h4 id="srt-scale-rotate-translate-operations">SRT (Scale-Rotate-Translate) operations</h4>
<p>Now we've defined the operations we like the most to describe (sort-of) real world objects moved around in space. Let's spend a few paragraphs talking about how to combine all of the operations together.</p>
<p>If you recall, geometric operations are <em>non-commutative</em>, which means that if we defined them in a specific order, there's no guarantee that changing the order will provide us with similar results. <del>That means that when building a graphics system we need to exercise systematic vigilance when executing human stuff like "Turn that spindle around so I may see its refractions of the sun" without accidentally turning the sun around its' axis, incinerating the good people of Uranus.</del> <strong>[mh: this felt distracting]</strong></p>
<p>The way we execute that vigilance is by a predefined order for handling objects. If you grab a pen and paper it won't take too long to figure that order out: 1. Modify the scale (if need be). 2. Modify the orientation (if need be). 3. Modify the position (if need be). 4. Rejoice.</p>
<p>Any other order will cause weird effects, like things growing and spinning off their axes (anchor point / pivot, if animation is your jam). This may seem like common sense, but Ken Perlin notes that it was only the late 80s when that system became a standard for 3d.</p>
<p>This set of operations is called <em>SRT</em>, or <em>Scale-Rotate-Translate</em>, because it can be described by the following sequence of matrices: <span class="math">\[T⋅R⋅S⋅v\]</span> Where the first operation occuring is the one most adjacent to the vector <span class="math">\(v\)</span>.</p>
<p>If you recall, we can multiply all of these matrices to get one matrix representing all the entire operation: <span class="math">\[M = T⋅R⋅S\]</span></p>
<p>We call this matrix <span class="math">\(M\)</span>, because it places objects we give it in their place in the <em>Model</em>. Whenever you call <code>ofTranslate()</code>, <code>ofRotate()</code>, <code>ofScale()</code> (or equivalent) on an object, that operation is applied to the <strong>currently active <em>Model</em> matrix</strong>. Whenever you execute <code>ofPushMatrix()</code>, a copy of that matrix is saved in <em>the matrix stack</em>, so that you can go back to it when necessary. And when necessary, you will then use <code>ofPopMatrix()</code>, which will cause the current matrix <span class="math">\(M\)</span> to be deleted and replace it with a matrix from the top of the matrix stack. That is the entire mystery about matrices. That's it.</p>
<h4 id="using-matrices-and-quaternions-in-openframeworks">Using Matrices and Quaternions in openFrameworks</h4>
<p>While this chapter was supposed to show the underlying representation of grpahics operations, it did intentionally avoid showing matrix examples in code. Now that you know how matrices look on the inside, it'll be a lot easier for you to figure out how to debug your 3d code, but most of the time using matrices in raw form won't be necessary.</p>
<p>While you could construct a matrix via <code>ofMatrix4x4</code>, using:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofMatrix4x4( <span class="dt">const</span> ofQuaternion&amp; quat ) {
	makeRotationMatrix(quat);
}

ofMatrix4x4(	<span class="dt">float</span> a00, <span class="dt">float</span> a01, <span class="dt">float</span> a02, <span class="dt">float</span> a03,
              <span class="dt">float</span> a10, <span class="dt">float</span> a11, <span class="dt">float</span> a12, <span class="dt">float</span> a13,
              <span class="dt">float</span> a20, <span class="dt">float</span> a21, <span class="dt">float</span> a22, <span class="dt">float</span> a23,
              <span class="dt">float</span> a30, <span class="dt">float</span> a31, <span class="dt">float</span> a32, <span class="dt">float</span> a33);</code></pre>
<p>You'll mostly find that what matters to you is the Algebra of the Operation, not the actual numbers, so you'll be much better off using these:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ofMatrix4x4::makeScaleMatrix( <span class="dt">const</span> ofVec3f&amp; );
<span class="dt">void</span> ofMatrix4x4::makeScaleMatrix( <span class="dt">float</span>, <span class="dt">float</span>, <span class="dt">float</span> );

<span class="dt">void</span> ofMatrix4x4::makeTranslationMatrix( <span class="dt">const</span> ofVec3f&amp; );
<span class="dt">void</span> ofMatrix4x4::makeTranslationMatrix( <span class="dt">float</span>, <span class="dt">float</span>, <span class="dt">float</span> );

<span class="dt">void</span> ofMatrix4x4::makeRotationMatrix( <span class="dt">const</span> ofVec3f&amp; from, <span class="dt">const</span> ofVec3f&amp; to );
<span class="dt">void</span> ofMatrix4x4::makeRotationMatrix( <span class="dt">float</span> angle, <span class="dt">const</span> ofVec3f&amp; axis );
<span class="dt">void</span> ofMatrix4x4::makeRotationMatrix( <span class="dt">float</span> angle, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z );
<span class="dt">void</span> ofMatrix4x4::makeRotationMatrix( <span class="dt">const</span> ofQuaternion&amp; );
<span class="dt">void</span> ofMatrix4x4::makeRotationMatrix( <span class="dt">float</span> angle1, <span class="dt">const</span> ofVec3f&amp; axis1,
                 <span class="dt">float</span> angle2, <span class="dt">const</span> ofVec3f&amp; axis2,
                 <span class="dt">float</span> angle3, <span class="dt">const</span> ofVec3f&amp; axis3);</code></pre>
<p>All these things do is form Operations you can later multiply your <code>ofVec4f</code> objects with.</p>
<p>Here's the same example for Quaternions, using the <code>ofQuaternion</code> class:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* Axis-Angle Rotations*/</span>
<span class="dt">void</span> ofQuaternion::makeRotate(<span class="dt">float</span> angle, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z);
<span class="dt">void</span> ofQuaternion::makeRotate(<span class="dt">float</span> angle, <span class="dt">const</span> ofVec3f&amp; vec);
<span class="dt">void</span> ofQuaternion::makeRotate(<span class="dt">float</span> angle1, <span class="dt">const</span> ofVec3f&amp; axis1, <span class="dt">float</span> angle2, <span class="dt">const</span> ofVec3f&amp; axis2, <span class="dt">float</span> angle3, <span class="dt">const</span> ofVec3f&amp; axis3);

<span class="co">/* From-To Rotations */</span>
<span class="dt">void</span> ofQuaternion::makeRotate(<span class="dt">const</span> ofVec3f&amp; vec1, <span class="dt">const</span> ofVec3f&amp; vec2);</code></pre>
<p>Just like with Matrices, any of these objects create a <em>rotation operation</em> that can later be applied to a vector:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">ofVec3f myUnrotatedVector(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>);
ofQuaternion quat;
quat.makeRotate(ofVec3f(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), ofVec3f(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>));
ofVec3f myRotatedVector = quat * myUnrotatedVector;
cout &lt;&lt; ofToString(myRotatedVector) &lt;&lt; endl;
<span class="co">//prints out (0,1,0)</span></code></pre>
<h6 id="ok-now-what">Ok, Now What?</h6>
<p>This chapter is done. It's just the tip of the iceberg in what math can do for graphics.</p>
<p>In the 'Advanced Graphics' chapter you'll learn about two similar matrices: * The <em>View</em> matrix tramsforms the result of the <em>Model</em> matrix to simulate where our camera is supposed to be at. * The <em>Projection</em> matrix applies the optical properties of the camera we defined and turns the result of the <em>View</em> matrix from a 3D space to a 2D image. The Projection matrix is built slightly different than the <em>Model-View</em> matrix, but if you've made it this far, you won't have trouble reading about it in a special Graphics topic.</p>
<h6 id="also-thanks">Also, Thanks</h6>
<p>Learning Math is hard. Teaching Math is therefore excruciating: having so many ideas you want to put in someone else's head, and the slow and sticky nature of it all. I'd like to thank Prof. Bo'az Klartag and Prof. Ken Perlin and for giving me ideas on how to teach mathematics intuitively.</p>
</div>
</body>
</html>
